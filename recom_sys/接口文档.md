# -*- coding: utf-8 -*-
from flask import Flask, render_template, jsonify, request, session, redirect, url_for
from datetime import datetime
import math
import os
import hashlib

app = Flask(__name__)
app.secret_key = 'your_secret_key_here'  # 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷应锟斤拷使锟矫革拷锟斤拷全锟斤拷锟斤拷钥

def _env(name, default=None):
    v = os.environ.get(name)
    return v if v is not None else default

OPENGAUSS_HOST = _env('OPENGAUSS_HOST', '139.9.116.109')
OPENGAUSS_PORT = int(_env('OPENGAUSS_PORT', '26000'))
OPENGAUSS_DB = _env('OPENGAUSS_DB', 'mytest')
OPENGAUSS_USER = _env('OPENGAUSS_USER', 'sqy')
OPENGAUSS_PASSWORD = _env('OPENGAUSS_PASSWORD', '451278963Qwe')
OPENGAUSS_SSLMODE = _env('OPENGAUSS_SSLMODE')
# jdbc:postgresql://139.9.116.109:26000/mytest
DATABASE_URL = _env('DATABASE_URL', f'postgresql://{OPENGAUSS_USER}:{OPENGAUSS_PASSWORD}@{OPENGAUSS_HOST}:{OPENGAUSS_PORT}/{OPENGAUSS_DB}')
app.config['DATABASE_URL'] = DATABASE_URL
app.config['SQLALCHEMY_DATABASE_URI'] = DATABASE_URL
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {'pool_pre_ping': True, 'pool_recycle': 1800, 'pool_size': 5, 'max_overflow': 10}

DB = None

def _hash_password(p):
    s = os.environ.get('PASSWORD_SALT') or ''
    return hashlib.sha256((p + s).encode('utf-8')).hexdigest()

def init_db():
    global DB
    try:
        import psycopg2
        kwargs = {
            'host': OPENGAUSS_HOST,
            'port': OPENGAUSS_PORT,
            'dbname': OPENGAUSS_DB,
            'user': OPENGAUSS_USER,
            'password': OPENGAUSS_PASSWORD
        }
        if OPENGAUSS_SSLMODE:
            kwargs['sslmode'] = OPENGAUSS_SSLMODE
        conn = psycopg2.connect(**kwargs)
        DB = {'type': 'psycopg2', 'conn': conn}
        return DB
    except Exception:
        try:
            from sqlalchemy import create_engine
            engine = create_engine(app.config['SQLALCHEMY_DATABASE_URI'], **app.config.get('SQLALCHEMY_ENGINE_OPTIONS', {}))
            DB = {'type': 'sqlalchemy', 'engine': engine}
            return DB
        except Exception:
            DB = None
            return None

def get_db_connection():
    if DB is None:
        return None
    if DB.get('type') == 'sqlalchemy':
        return DB['engine'].connect()
    if DB.get('type') == 'psycopg2':
        conn = DB.get('conn')
        try:
            if not conn or getattr(conn, 'closed', 1) != 0:
                import psycopg2
                kwargs = {
                    'host': OPENGAUSS_HOST,
                    'port': OPENGAUSS_PORT,
                    'dbname': OPENGAUSS_DB,
                    'user': OPENGAUSS_USER,
                    'password': OPENGAUSS_PASSWORD
                }
                if OPENGAUSS_SSLMODE:
                    kwargs['sslmode'] = OPENGAUSS_SSLMODE
                DB['conn'] = psycopg2.connect(**kwargs)
                conn = DB['conn']
        except Exception:
            return None
        return conn
    return None

init_db()

# ==========================================
# 1. 模锟斤拷锟斤拷锟捷匡拷 (In-Memory Database)
# ==========================================

# 锟矫伙拷锟斤拷 tb_users
USERS = [
    {
        "userId": 1,
        "username": "admin",
        "password": "admin123",
        "email": "admin@example.com",
        "avatarUrl": None,
        "status": 1,
        "createdAt": datetime.now().isoformat()
    },
    {
        "userId": 2,
        "username": "user",
        "password": "password",
        "email": "user@example.com",
        "avatarUrl": None,
        "status": 1,
        "createdAt": datetime.now().isoformat()
    }
]

# 锟斤拷锟捷憋拷 tb_items
ITEMS = [
    # Books
    {"itemId": 1, "title": "锟斤拷锟斤拷", "type": "book", "authorDirector": "锟斤拷锟斤拷锟斤拷", "releaseYear": 2006, "ratingAvg": 9.2, "ratingCount": 1000, "viewCount": 5000, "coverUrl": "https://luoxiadushu.com/images/2015/07/santi-1.jpg", "description": "锟侥伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷荼锟斤拷锟叫碉拷同时锟斤拷锟斤拷锟斤拷探寻锟斤拷锟斤拷锟斤拷锟斤拷锟侥撅拷锟截计伙拷锟斤拷锟届岸锟斤拷锟教★拷取锟斤拷锟斤拷突锟斤拷锟皆斤拷展...", "createdAt": datetime.now().isoformat()},
    {"itemId": 2, "title": "锟斤拷锟斤拷", "type": "book", "authorDirector": "锟洁华", "releaseYear": 1993, "ratingAvg": 9.1, "ratingCount": 900, "viewCount": 4500, "coverUrl": "https://img-s.msn.cn/tenant/amp/entityid/AA1RqLkK.img?w=600&h=590&m=6", "description": "锟斤拷锟斤拷锟脚★拷锟斤拷锟斤拷锟斤拷农锟斤拷锟剿革拷锟襟悲惨碉拷锟斤拷锟斤拷锟斤拷锟斤拷...", "createdAt": datetime.now().isoformat()},
    {"itemId": 3, "title": "锟斤拷锟斤拷露锟�", "type": "book", "authorDirector": "锟斤拷锟斤拷锟角★拷锟斤拷锟斤拷锟斤拷斯", "releaseYear": 1967, "ratingAvg": 9.2, "ratingCount": 850, "viewCount": 4000, "coverUrl": "https://img3.doubanio.com/view/subject/s/public/s27270478.jpg", "description": "锟斤拷锟斤拷锟斤拷露锟斤拷锟斤拷锟斤拷歉锟斤拷妆锟斤拷锟斤拷锟斤拷壹锟斤拷锟斤拷恰锟斤拷锟斤拷锟斤拷锟剿癸拷锟斤拷锟斤拷某锟狡∷�...", "createdAt": datetime.now().isoformat()},
    {"itemId": 4, "title": "围锟斤拷", "type": "book", "authorDirector": "钱锟斤拷锟斤拷", "releaseYear": 1947, "ratingAvg": 8.9, "ratingCount": 800, "viewCount": 3500, "coverUrl": "https://img3.doubanio.com/view/subject/s/public/s27270479.jpg", "description": "锟斤拷围锟角★拷锟斤拷钱锟斤拷锟斤拷锟斤拷锟斤拷锟侥筹拷篇小说...", "createdAt": datetime.now().isoformat()},
    {"itemId": 5, "title": "平锟斤拷锟斤拷锟斤拷锟斤拷", "type": "book", "authorDirector": "路遥", "releaseYear": 1986, "ratingAvg": 9.0, "ratingCount": 950, "viewCount": 4800, "coverUrl": "https://img3.doubanio.com/view/subject/s/public/s27270480.jpg", "description": "锟斤拷平锟斤拷锟斤拷锟斤拷锟界》锟斤拷锟叫癸拷锟斤拷锟斤拷路遥锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷锟斤拷锟街碉拷小说...", "createdAt": datetime.now().isoformat()},
    {"itemId": 6, "title": "锟斤拷楼锟斤拷", "type": "book", "authorDirector": "锟斤拷雪锟斤拷", "releaseYear": 1791, "ratingAvg": 9.6, "ratingCount": 2000, "viewCount": 10000, "coverUrl": "https://img3.doubanio.com/view/subject/s/public/s27270481.jpg", "description": "锟斤拷锟斤拷楼锟轿★拷锟斤拷一锟斤拷锟劫匡拷全锟斤拷式锟侥筹拷篇小说...", "createdAt": datetime.now().isoformat()},
    
    # Movies (IDs start from 101 to match old data logic, though not strictly necessary)
    {"itemId": 101, "title": "肖锟斤拷说木锟斤拷锟�", "type": "movie", "authorDirector": "锟斤拷锟斤拷锟剿★拷锟斤拷锟斤拷锟斤拷锟斤拷", "releaseYear": 1994, "ratingAvg": 9.7, "ratingCount": 3000, "viewCount": 15000, "coverUrl": "https://img3.doubanio.com/view/photo/s/public/p480747492.jpg", "description": "一锟斤拷谋杀锟斤拷使锟斤拷锟叫家帮拷锟斤拷锟斤拷冤锟斤拷锟斤拷...", "createdAt": datetime.now().isoformat()},
    {"itemId": 102, "title": "锟斤拷锟斤拷锟斤拷锟斤拷", "type": "movie", "authorDirector": "锟睫诧拷锟截★拷锟斤拷锟阶硷拷斯", "releaseYear": 1994, "ratingAvg": 9.5, "ratingCount": 2500, "viewCount": 12000, "coverUrl": "https://img3.doubanio.com/view/photo/s/public/p510876377.jpg", "description": "锟斤拷锟斤拷锟节讹拷战锟斤拷锟斤拷锟襟不久筹拷锟斤拷...", "createdAt": datetime.now().isoformat()},
    {"itemId": 103, "title": "锟斤拷锟轿空硷拷", "type": "movie", "authorDirector": "锟斤拷锟斤拷斯锟叫革拷锟斤拷诺锟斤拷", "releaseYear": 2010, "ratingAvg": 9.3, "ratingCount": 2200, "viewCount": 11000, "coverUrl": "https://img3.doubanio.com/view/photo/s/public/p513344864.jpg", "description": "锟斤拷姆锟斤拷锟铰诧拷锟斤拷同锟铰帮拷瑟...", "createdAt": datetime.now().isoformat()},
    {"itemId": 104, "title": "泰坦锟斤拷撕锟�", "type": "movie", "authorDirector": "詹姆斯锟斤拷锟斤拷梅隆", "releaseYear": 1997, "ratingAvg": 9.4, "ratingCount": 2800, "viewCount": 14000, "coverUrl": "https://img3.doubanio.com/view/photo/s/public/p457760035.jpg", "description": "1912锟斤拷4锟斤拷10锟斤拷...", "createdAt": datetime.now().isoformat()},
    {"itemId": 105, "title": "锟角际达拷越", "type": "movie", "authorDirector": "锟斤拷锟斤拷斯锟叫革拷锟斤拷诺锟斤拷", "releaseYear": 2014, "ratingAvg": 9.3, "ratingCount": 2100, "viewCount": 10500, "coverUrl": "https://img3.doubanio.com/view/photo/s/public/p2206088801.jpg", "description": "锟斤拷未锟斤拷锟侥碉拷锟斤拷锟缴筹拷锟揭�...", "createdAt": datetime.now().isoformat()},
    {"itemId": 106, "title": "锟斤拷锟脚碉拷锟斤拷锟斤拷", "type": "movie", "authorDirector": "锟剿得★拷锟斤拷锟斤拷", "releaseYear": 1998, "ratingAvg": 9.3, "ratingCount": 2300, "viewCount": 11500, "coverUrl": "https://img3.doubanio.com/view/photo/s/public/p479682983.jpg", "description": "锟斤拷锟斤拷锟斤拷一锟斤拷平锟斤拷锟矫诧拷锟斤拷锟斤拷平锟斤拷锟斤拷锟斤拷锟斤拷...", "createdAt": datetime.now().isoformat()}
]

# 锟斤拷签锟斤拷 tb_tags
TAGS = [
    {"tagId": 1, "tagName": "锟狡伙拷", "itemCount": 4},
    {"tagId": 2, "tagName": "锟斤拷锟斤拷", "itemCount": 4},
    {"tagId": 3, "tagName": "锟缴筹拷", "itemCount": 3},
    {"tagId": 4, "tagName": "锟斤拷锟斤拷", "itemCount": 4},
    {"tagId": 5, "tagName": "锟斤拷锟斤拷", "itemCount": 2},
    {"tagId": 6, "tagName": "锟斤拷史", "itemCount": 2}
]

# 锟斤拷锟斤拷-锟斤拷签锟斤拷锟斤拷锟斤拷 tb_item_tags
ITEM_TAGS = [
    {"itemId": 1, "tagId": 1}, # 锟斤拷锟斤拷 - 锟狡伙拷
    {"itemId": 105, "tagId": 1}, # 锟角际达拷越 - 锟狡伙拷
    {"itemId": 103, "tagId": 1}, # 锟斤拷锟轿空硷拷 - 锟狡伙拷
    {"itemId": 103, "tagId": 2}, # 锟斤拷锟轿空硷拷 - 锟斤拷锟斤拷
    {"itemId": 6, "tagId": 2}, # 锟斤拷楼锟斤拷 - 锟斤拷锟斤拷 (just sample logic from js)
    {"itemId": 6, "tagId": 4}, # 锟斤拷楼锟斤拷 - 锟斤拷锟斤拷
    {"itemId": 6, "tagId": 5}, # 锟斤拷楼锟斤拷 - 锟斤拷锟斤拷
    {"itemId": 4, "tagId": 2}, # 围锟斤拷 - 锟斤拷锟斤拷
    {"itemId": 101, "tagId": 2}, # 肖锟斤拷锟� - 锟斤拷锟斤拷
    {"itemId": 101, "tagId": 4}, # 肖锟斤拷锟� - 锟斤拷锟斤拷
    {"itemId": 106, "tagId": 2}, # 锟斤拷锟斤拷 - 锟斤拷锟斤拷
    {"itemId": 5, "tagId": 3}, # 平锟斤拷锟斤拷锟斤拷锟斤拷 - 锟缴筹拷
    {"itemId": 5, "tagId": 6}, # 平锟斤拷锟斤拷锟斤拷锟斤拷 - 锟斤拷史
    {"itemId": 2, "tagId": 3}, # 锟斤拷锟斤拷 - 锟缴筹拷
    {"itemId": 102, "tagId": 3}, # 锟斤拷锟斤拷 - 锟缴筹拷
    {"itemId": 102, "tagId": 4}, # 锟斤拷锟斤拷 - 锟斤拷锟斤拷
    {"itemId": 3, "tagId": 4}, # 锟斤拷锟斤拷露锟� - 锟斤拷锟斤拷
    {"itemId": 104, "tagId": 5}, # 泰坦锟斤拷锟� - 锟斤拷锟斤拷
]

# 锟斤拷锟街憋拷 tb_ratings
RATINGS = []

# 锟秸藏憋拷 tb_favorites
FAVORITES = []

# ==========================================
# 2. 锟斤拷锟斤拷锟斤拷锟斤拷
# ==========================================

def get_current_user():
    if 'username' not in session:
        return None
    username = session['username']
    
    # 锟斤拷锟饺筹拷锟皆达拷锟斤拷锟捷匡拷锟饺★拷没锟斤拷锟较�
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                row = conn.execute(text("SELECT user_id, username, email, avatar_url FROM tb_users WHERE username=:u"), {"u": username}).fetchone()
                if row:
                    return {
                        "userId": row[0],
                        "username": row[1],
                        "email": row[2],
                        "avatarUrl": row[3]
                    }
            else:
                cur = conn.cursor()
                cur.execute("SELECT user_id, username, email, avatar_url FROM tb_users WHERE username=%s", (username,))
                row = cur.fetchone()
                cur.close()
                if row:
                    return {
                        "userId": row[0],
                        "username": row[1],
                        "email": row[2],
                        "avatarUrl": row[3]
                    }
        except Exception:
            pass
    
    # 锟斤拷锟斤拷锟斤拷菘獠伙拷锟斤拷茫锟斤拷锟斤拷说锟斤拷诖锟斤拷械锟斤拷没锟斤拷斜锟�
    return next((u for u in USERS if u['username'] == username), None)

def get_item_by_id(item_id):
    return next((i for i in ITEMS if i['itemId'] == item_id), None)

def get_item_tags(item_id):
    tag_ids = [it['tagId'] for it in ITEM_TAGS if it['itemId'] == item_id]
    tags = [t['tagName'] for t in TAGS if t['tagId'] in tag_ids]
    return tags

# ==========================================
# 3. 锟斤拷图路锟斤拷 (View Routes)
# ==========================================

@app.route('/')
def index():
    """锟斤拷页"""
    if 'username' not in session:
        return redirect(url_for('login_page'))
    return render_template('index.html')

@app.route('/login')
def login_page():
    """锟斤拷录页锟斤拷"""
    if 'username' in session:
        return redirect(url_for('index'))
    return render_template('login.html')

@app.route('/profile')
def profile_page():
    if 'username' not in session:
        return redirect(url_for('login_page'))
    user = get_current_user()
    return render_template('profile.html', user=user)

@app.route('/detail/<item_type>/<int:item_id>')
def detail(item_type, item_id):
    if 'username' not in session:
        return redirect(url_for('login_page'))

    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                r = conn.execute(text("SELECT item_id, title, type, author_director, release_year, rating_avg, rating_count, view_count, cover_url, description FROM tb_items WHERE item_id=:id"), {'id': item_id}).fetchone()
                if not r:
                    conn.close()
                    return "锟斤拷目未锟揭碉拷", 404
                item_copy = {
                    'itemId': r[0],
                    'title': r[1],
                    'type': r[2],
                    'authorDirector': r[3],
                    'releaseYear': r[4],
                    'ratingAvg': float(r[5]) if r[5] is not None else 0.0,
                    'ratingCount': int(r[6]) if r[6] is not None else 0,
                    'viewCount': int(r[7]) if r[7] is not None else 0,
                    'coverUrl': r[8],
                    'description': r[9]
                }
                trows = conn.execute(text("SELECT t.tag_name FROM tb_item_tags it JOIN tb_tags t ON t.tag_id=it.tag_id WHERE it.item_id=:id"), {'id': item_id}).fetchall()
                item_copy['tags'] = [x[0] for x in trows]
                user = get_current_user()
                item_copy['isFavorited'] = False
                item_copy['userRating'] = None
                if user:
                    fav = conn.execute(text("SELECT 1 FROM tb_favorites WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id}).fetchone()
                    item_copy['isFavorited'] = bool(fav)
                    rrow = conn.execute(text("SELECT score FROM tb_ratings WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id}).fetchone()
                    if rrow:
                        item_copy['userRating'] = int(rrow[0])
                item_copy['id'] = item_copy['itemId']
                item_copy['year'] = item_copy['releaseYear']
                item_copy['rating'] = item_copy['ratingAvg']
                item_copy['cover'] = item_copy['coverUrl']
                if item_copy['type'] == 'book':
                    item_copy['author'] = item_copy['authorDirector']
                else:
                    item_copy['director'] = item_copy['authorDirector']
                conn.close()
                return render_template('detail.html', item=item_copy, item_type=item_type)
            else:
                cur = conn.cursor()
                cur.execute("SELECT item_id, title, type, author_director, release_year, rating_avg, rating_count, view_count, cover_url, description FROM tb_items WHERE item_id=%s", (item_id,))
                r = cur.fetchone()
                if not r:
                    cur.close()
                    return "锟斤拷目未锟揭碉拷", 404
                item_copy = {
                    'itemId': r[0], 'title': r[1], 'type': r[2], 'authorDirector': r[3], 'releaseYear': r[4], 'ratingAvg': float(r[5]) if r[5] is not None else 0.0, 'ratingCount': int(r[6]) if r[6] is not None else 0, 'viewCount': int(r[7]) if r[7] is not None else 0, 'coverUrl': r[8], 'description': r[9]
                }
                cur.execute("SELECT t.tag_name FROM tb_item_tags it JOIN tb_tags t ON t.tag_id=it.tag_id WHERE it.item_id=%s", (item_id,))
                item_copy['tags'] = [x[0] for x in cur.fetchall()]
                user = get_current_user()
                item_copy['isFavorited'] = False
                item_copy['userRating'] = None
                if user:
                    cur.execute("SELECT 1 FROM tb_favorites WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                    item_copy['isFavorited'] = cur.fetchone() is not None
                    cur.execute("SELECT score FROM tb_ratings WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                    rrow = cur.fetchone()
                    if rrow:
                        item_copy['userRating'] = int(rrow[0])
                cur.close()
                item_copy['id'] = item_copy['itemId']
                item_copy['year'] = item_copy['releaseYear']
                item_copy['rating'] = item_copy['ratingAvg']
                item_copy['cover'] = item_copy['coverUrl']
                if item_copy['type'] == 'book':
                    item_copy['author'] = item_copy['authorDirector']
                else:
                    item_copy['director'] = item_copy['authorDirector']
                return render_template('detail.html', item=item_copy, item_type=item_type)
        except Exception:
            pass

    return "锟斤拷锟捷库不锟斤拷锟斤拷", 500

# ==========================================
# 4. API 锟接匡拷 (API Routes)
# ==========================================

# --- 4.1 锟斤拷锟斤拷锟接匡拷 (/api/public) ---

@app.route('/api/public/register', methods=['POST'])
def api_register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    email = data.get('email')
    now_dt = datetime.now()
    new_id = None
    hashed = _hash_password(password or '')
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                with conn.begin():
                    exists = conn.execute(text("SELECT 1 FROM tb_users WHERE username=:username"), {"username": username}).fetchone()
                    if exists:
                        return jsonify({"code": 400, "message": "锟矫伙拷锟斤拷锟窖达拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
                    row = conn.execute(text("INSERT INTO tb_users (username, password, email, avatar_url, status, created_at) VALUES (:username, :password, :email, :avatar_url, :status, :created_at) RETURNING user_id"), {"username": username, "password": hashed, "email": email, "avatar_url": None, "status": 1, "created_at": now_dt}).fetchone()
                    if row:
                        new_id = row[0]
                conn.close()
            else:
                cur = conn.cursor()
                cur.execute("SELECT 1 FROM tb_users WHERE username=%s", (username,))
                if cur.fetchone():
                    cur.close()
                    return jsonify({"code": 400, "message": "锟矫伙拷锟斤拷锟窖达拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
                cur.execute("INSERT INTO tb_users (username, password, email, avatar_url, status, created_at) VALUES (%s, %s, %s, %s, %s, %s) RETURNING user_id", (username, hashed, email, None, 1, now_dt))
                row = cur.fetchone()
                if row:
                    new_id = row[0]
                conn.commit()
                cur.close()
        except Exception:
            try:
                if DB.get('type') == 'sqlalchemy':
                    from sqlalchemy import text
                    conn.execute(text("CREATE TABLE IF NOT EXISTS tb_users (user_id BIGSERIAL PRIMARY KEY, username VARCHAR(50) UNIQUE NOT NULL, password VARCHAR(255) NOT NULL, email VARCHAR(100), avatar_url VARCHAR(255), status SMALLINT NOT NULL DEFAULT 1, created_at TIMESTAMP NOT NULL)"))
                    row = conn.execute(text("INSERT INTO tb_users (username, password, email, avatar_url, status, created_at) VALUES (:username, :password, :email, :avatar_url, :status, :created_at) RETURNING user_id"), {"username": username, "password": hashed, "email": email, "avatar_url": None, "status": 1, "created_at": now_dt}).fetchone()
                    if row:
                        new_id = row[0]
                    conn.close()
                else:
                    cur = conn.cursor()
                    cur.execute("CREATE TABLE IF NOT EXISTS tb_users (user_id BIGSERIAL PRIMARY KEY, username VARCHAR(50) UNIQUE NOT NULL, password VARCHAR(255) NOT NULL, email VARCHAR(100), avatar_url VARCHAR(255), status SMALLINT NOT NULL DEFAULT 1, created_at TIMESTAMP NOT NULL)")
                    cur.execute("INSERT INTO tb_users (username, password, email, avatar_url, status, created_at) VALUES (%s, %s, %s, %s, %s, %s) RETURNING user_id", (username, hashed, email, None, 1, now_dt))
                    row = cur.fetchone()
                    if row:
                        new_id = row[0]
                    conn.commit()
                    cur.close()
            except Exception:
                new_id = None
    if new_id is None:
        if any(u['username'] == username for u in USERS):
            return jsonify({"code": 400, "message": "锟矫伙拷锟斤拷锟窖达拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
        new_user = {
            "userId": len(USERS) + 1,
            "username": username,
            "password": password,
            "email": email,
            "avatarUrl": None,
            "status": 1,
            "createdAt": now_dt.isoformat()
        }
        USERS.append(new_user)
        return jsonify({
            "code": 200,
            "message": "注锟斤拷晒锟�",
            "data": {"userId": new_user['userId'], "username": new_user['username']},
            "timestamp": int(datetime.now().timestamp() * 1000)
        })
    USERS.append({
        "userId": new_id,
        "username": username,
        "password": hashed,
        "email": email,
        "avatarUrl": None,
        "status": 1,
        "createdAt": now_dt.isoformat()
    })
    return jsonify({
        "code": 200,
        "message": "注锟斤拷晒锟�",
        "data": {"userId": new_id, "username": username},
        "timestamp": int(datetime.now().timestamp() * 1000)
    })

@app.route('/api/public/login', methods=['POST'])
def api_public_login():
    data = request.get_json() or {}
    username = data.get('username')
    password = data.get('password')

    if not username or not password:
        return jsonify({
            "code": 400,
            "message": "缺锟斤拷锟矫伙拷锟斤拷锟斤拷锟斤拷锟斤拷",
            "data": None,
            "timestamp": int(datetime.now().timestamp() * 1000)
        })

    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                exists_row = conn.execute(text("SELECT user_id, password FROM tb_users WHERE username=:u"), {"u": username}).fetchone()
                if not exists_row:
                    conn.close()
                    return jsonify({"code": 401, "message": "锟矫伙拷锟斤拷锟斤拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
                if exists_row[1] != _hash_password(password):
                    conn.close()
                    return jsonify({"code": 401, "message": "锟矫伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
                session['username'] = username
                resp = jsonify({
                    "code": 200,
                    "message": "锟斤拷录锟缴癸拷",
                    "data": {
                        "accessToken": "mock_token",
                        "user": {"userId": exists_row[0], "username": username}
                    },
                    "timestamp": int(datetime.now().timestamp() * 1000)
                })
                conn.close()
                return resp
            else:
                cur = conn.cursor()
                cur.execute("SELECT user_id, password FROM tb_users WHERE username=%s", (username,))
                exists_row = cur.fetchone()
                cur.close()
                if not exists_row:
                    return jsonify({"code": 401, "message": "锟矫伙拷锟斤拷锟斤拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
                if exists_row[1] != _hash_password(password):
                    return jsonify({"code": 401, "message": "锟矫伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
                session['username'] = username
                return jsonify({
                    "code": 200,
                    "message": "锟斤拷录锟缴癸拷",
                    "data": {
                        "accessToken": "mock_token",
                        "user": {"userId": exists_row[0], "username": username}
                    },
                    "timestamp": int(datetime.now().timestamp() * 1000)
                })
        except Exception:
            pass

    user = next((u for u in USERS if u['username'] == username and u['password'] == password), None)
    if user:
        session['username'] = username
        return jsonify({
            "code": 200,
            "message": "锟斤拷录锟缴癸拷",
            "data": {
                "accessToken": "mock_token",
                "user": {"userId": user['userId'], "username": user['username']}
            },
            "timestamp": int(datetime.now().timestamp() * 1000)
        })
    if not any(u['username'] == username for u in USERS):
        return jsonify({"code": 401, "message": "锟矫伙拷锟斤拷锟斤拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
    return jsonify({"code": 401, "message": "锟矫伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})

# 锟斤拷锟捷旧接匡拷 /api/login
@app.route('/api/login', methods=['POST'])
def api_login_compat():
    return api_public_login()

@app.route('/api/public/items', methods=['GET'])
def api_get_items():
    page = int(request.args.get('page', 1))
    size = int(request.args.get('size', 100))
    item_type = request.args.get('type')
    keyword = request.args.get('keyword', '').lower()
    tag_id = request.args.get('tagId')
    sort_by = request.args.get('sortBy', 'createdAt')
    order = request.args.get('order', 'desc').lower()
    if order not in ('asc','desc'):
        order = 'desc'

    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                params = {}
                where = []
                if item_type:
                    if item_type == 'books':
                        where.append("i.type='book'")
                    elif item_type == 'movies':
                        where.append("i.type='movie'")
                    else:
                        where.append("i.type=:type")
                        params['type'] = item_type
                if keyword:
                    where.append("(LOWER(i.title) LIKE :kw OR LOWER(i.author_director) LIKE :kw)")
                    params['kw'] = f"%{keyword}%"
                join = ''
                if tag_id:
                    join = 'JOIN tb_item_tags it ON it.item_id=i.item_id AND it.tag_id=:tagId'
                    params['tagId'] = int(tag_id)
                where_sql = ('WHERE ' + ' AND '.join(where)) if where else ''
                count_sql = f"SELECT COUNT(*) FROM tb_items i {join} {where_sql}"
                total = conn.execute(text(count_sql), params).scalar() or 0
                offset = (page - 1) * size
                col_map = {'createdAt': 'i.created_at', 'ratingAvg': 'i.rating_avg', 'viewCount': 'i.view_count'}
                sort_col = col_map.get(sort_by, 'i.created_at')
                list_sql = f"SELECT i.item_id, i.title, i.type, i.author_director, i.release_year, i.rating_avg, i.rating_count, i.view_count, i.cover_url, i.description FROM tb_items i {join} {where_sql} ORDER BY {sort_col} {order.upper()} LIMIT :size OFFSET :offset"
                params['size'] = size
                params['offset'] = offset
                rows = conn.execute(text(list_sql), params).fetchall()
                records = []
                for r in rows:
                    d = {
                        'itemId': r[0],
                        'title': r[1],
                        'type': r[2],
                        'authorDirector': r[3],
                        'releaseYear': r[4],
                        'ratingAvg': float(r[5]) if r[5] is not None else 0.0,
                        'ratingCount': int(r[6]) if r[6] is not None else 0,
                        'viewCount': int(r[7]) if r[7] is not None else 0,
                        'coverUrl': r[8],
                        'description': r[9]
                    }
                    records.append(d)
                if records:
                    for rec in records:
                        trows = conn.execute(text("SELECT t.tag_name FROM tb_item_tags it JOIN tb_tags t ON t.tag_id=it.tag_id WHERE it.item_id=:iid"), {'iid': rec['itemId']}).fetchall()
                        rec['tags'] = [x[0] for x in trows]
                return jsonify({
                    'code': 200,
                    'message': 'success',
                    'data': {
                        'currentPage': page,
                        'pageSize': size,
                        'total': int(total),
                        'totalPages': math.ceil(total / size) if size else 0,
                        'records': records,
                        'hasPrevious': page > 1,
                        'hasNext': (offset + size) < total
                    },
                    'timestamp': int(datetime.now().timestamp() * 1000)
                })
            else:
                cur = conn.cursor()
                params = []
                where = []
                if item_type:
                    if item_type == 'books':
                        where.append("i.type='book'")
                    elif item_type == 'movies':
                        where.append("i.type='movie'")
                    else:
                        where.append("i.type=%s")
                        params.append(item_type)
                if keyword:
                    where.append("(LOWER(i.title) LIKE %s OR LOWER(i.author_director) LIKE %s)")
                    params.extend([f"%{keyword}%", f"%{keyword}%"])
                join = ''
                if tag_id:
                    join = 'JOIN tb_item_tags it ON it.item_id=i.item_id AND it.tag_id=%s'
                    params.append(int(tag_id))
                where_sql = ('WHERE ' + ' AND '.join(where)) if where else ''
                cur.execute(f"SELECT COUNT(*) FROM tb_items i {join} {where_sql}", params)
                total = cur.fetchone()[0]
                offset = (page - 1) * size
                col_map = {'createdAt': 'i.created_at', 'ratingAvg': 'i.rating_avg', 'viewCount': 'i.view_count'}
                sort_col = col_map.get(sort_by, 'i.created_at')
                cur.execute(f"SELECT i.item_id, i.title, i.type, i.author_director, i.release_year, i.rating_avg, i.rating_count, i.view_count, i.cover_url, i.description FROM tb_items i {join} {where_sql} ORDER BY {sort_col} {order.upper()} LIMIT %s OFFSET %s", params + [size, offset])
                rows = cur.fetchall()
                records = []
                for r in rows:
                    records.append({
                        'itemId': r[0],
                        'title': r[1],
                        'type': r[2],
                        'authorDirector': r[3],
                        'releaseYear': r[4],
                        'ratingAvg': float(r[5]) if r[5] is not None else 0.0,
                        'ratingCount': int(r[6]) if r[6] is not None else 0,
                        'viewCount': int(r[7]) if r[7] is not None else 0,
                        'coverUrl': r[8],
                        'description': r[9]
                    })
                if records:
                    ids = tuple(rec['itemId'] for rec in records)
                    cur.execute("SELECT it.item_id, t.tag_name FROM tb_item_tags it JOIN tb_tags t ON t.tag_id=it.tag_id WHERE it.item_id IN %s", (ids,))
                    tag_rows = cur.fetchall()
                    tag_map = {}
                    for ir in tag_rows:
                        tag_map.setdefault(ir[0], []).append(ir[1])
                    for rec in records:
                        rec['tags'] = tag_map.get(rec['itemId'], [])
                cur.close()
                return jsonify({
                    'code': 200,
                    'message': 'success',
                    'data': {
                        'currentPage': page,
                        'pageSize': size,
                        'total': int(total),
                        'totalPages': math.ceil(total / size) if size else 0,
                        'records': records,
                        'hasPrevious': page > 1,
                        'hasNext': (offset + size) < total
                    },
                    'timestamp': int(datetime.now().timestamp() * 1000)
                })
        except Exception:
            pass
    # 锟斤拷锟捷库不锟斤拷锟斤拷时锟斤拷锟斤拷锟斤拷图锟斤拷/锟斤拷影目录锟斤拷锟斤拷使锟斤拷锟节达拷锟斤拷锟捷ｏ拷直锟接凤拷锟斤拷锟斤拷锟捷库不锟斤拷锟斤拷
    if item_type in ('book','books','movie','movies'):
        return jsonify({
            'code': 500,
            'message': '锟斤拷锟捷库不锟斤拷锟斤拷',
            'data': {
                'currentPage': page,
                'pageSize': size,
                'total': 0,
                'totalPages': 0,
                'records': [],
                'hasPrevious': False,
                'hasNext': False
            },
            'timestamp': int(datetime.now().timestamp() * 1000)
        }), 500
    if tag_id:
        return jsonify({
            'code': 500,
            'message': '锟斤拷锟捷库不锟斤拷锟斤拷',
            'data': {
                'currentPage': page,
                'pageSize': size,
                'total': 0,
                'totalPages': 0,
                'records': [],
                'hasPrevious': False,
                'hasNext': False
            },
            'timestamp': int(datetime.now().timestamp() * 1000)
        }), 500

    filtered_items = ITEMS
    if item_type:
        if item_type == 'books':
            filtered_items = [i for i in filtered_items if i['type'] == 'book']
        elif item_type == 'movies':
            filtered_items = [i for i in filtered_items if i['type'] == 'movie']
        else:
            filtered_items = [i for i in filtered_items if i['type'] == item_type]
    if keyword:
        filtered_items = [i for i in filtered_items if keyword in i['title'].lower() or keyword in i['authorDirector'].lower()]
    if tag_id:
        tag_id = int(tag_id)
        item_ids_with_tag = [it['itemId'] for it in ITEM_TAGS if it['tagId'] == tag_id]
        filtered_items = [i for i in filtered_items if i['itemId'] in item_ids_with_tag]
    col_map_mem = {'createdAt': 'createdAt', 'ratingAvg': 'ratingAvg', 'viewCount': 'viewCount'}
    sort_key = col_map_mem.get(sort_by, 'createdAt')
    try:
        if sort_key == 'createdAt':
            filtered_items = sorted(filtered_items, key=lambda i: i.get('createdAt') or '', reverse=(order=='desc'))
        else:
            filtered_items = sorted(filtered_items, key=lambda i: i.get(sort_key) or 0, reverse=(order=='desc'))
    except Exception:
        pass
    total = len(filtered_items)
    start = (page - 1) * size
    end = start + size
    records = filtered_items[start:end]
    for record in records:
        record['tags'] = get_item_tags(record['itemId'])
    return jsonify({
        'code': 200,
        'message': 'success',
        'data': {
            'currentPage': page,
            'pageSize': size,
            'total': total,
            'totalPages': math.ceil(total / size),
            'records': records,
            'hasPrevious': page > 1,
            'hasNext': end < total
        },
        'timestamp': int(datetime.now().timestamp() * 1000)
    })

@app.route('/api/public/items/<int:item_id>', methods=['GET'])
def api_get_item_detail(item_id):
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                r = conn.execute(text("SELECT item_id, title, type, author_director, release_year, rating_avg, rating_count, view_count, cover_url, description FROM tb_items WHERE item_id=:id"), {'id': item_id}).fetchone()
                if not r:
                    return jsonify({'code': 404, 'message': '锟斤拷源锟斤拷锟斤拷锟斤拷', 'data': None}), 404
                item_res = {
                    'itemId': r[0],
                    'title': r[1],
                    'type': r[2],
                    'authorDirector': r[3],
                    'releaseYear': r[4],
                    'ratingAvg': float(r[5]) if r[5] is not None else 0.0,
                    'ratingCount': int(r[6]) if r[6] is not None else 0,
                    'viewCount': int(r[7]) if r[7] is not None else 0,
                    'coverUrl': r[8],
                    'description': r[9]
                }
                trows = conn.execute(text("SELECT t.tag_name FROM tb_item_tags it JOIN tb_tags t ON t.tag_id=it.tag_id WHERE it.item_id=:id"), {'id': item_id}).fetchall()
                item_res['tags'] = [x[0] for x in trows]
                user = get_current_user()
                item_res['isFavorited'] = False
                item_res['userRating'] = None
                if user:
                    fav = conn.execute(text("SELECT 1 FROM tb_favorites WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id}).fetchone()
                    item_res['isFavorited'] = bool(fav)
                    rrow = conn.execute(text("SELECT score FROM tb_ratings WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id}).fetchone()
                    if rrow:
                        item_res['userRating'] = int(rrow[0])
                return jsonify({'code': 200, 'message': 'success', 'data': item_res, 'timestamp': int(datetime.now().timestamp() * 1000)})
            else:
                cur = conn.cursor()
                cur.execute("SELECT item_id, title, type, author_director, release_year, rating_avg, rating_count, view_count, cover_url, description FROM tb_items WHERE item_id=%s", (item_id,))
                r = cur.fetchone()
                if not r:
                    cur.close()
                    return jsonify({'code': 404, 'message': '锟斤拷源锟斤拷锟斤拷锟斤拷', 'data': None}), 404
                item_res = {
                    'itemId': r[0], 'title': r[1], 'type': r[2], 'authorDirector': r[3], 'releaseYear': r[4], 'ratingAvg': float(r[5]) if r[5] is not None else 0.0, 'ratingCount': int(r[6]) if r[6] is not None else 0, 'viewCount': int(r[7]) if r[7] is not None else 0, 'coverUrl': r[8], 'description': r[9]
                }
                cur.execute("SELECT t.tag_name FROM tb_item_tags it JOIN tb_tags t ON t.tag_id=it.tag_id WHERE it.item_id=%s", (item_id,))
                item_res['tags'] = [x[0] for x in cur.fetchall()]
                user = get_current_user()
                item_res['isFavorited'] = False
                item_res['userRating'] = None
                if user:
                    cur.execute("SELECT 1 FROM tb_favorites WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                    item_res['isFavorited'] = cur.fetchone() is not None
                    cur.execute("SELECT score FROM tb_ratings WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                    rrow = cur.fetchone()
                    if rrow:
                        item_res['userRating'] = int(rrow[0])
                cur.close()
                return jsonify({'code': 200, 'message': 'success', 'data': item_res, 'timestamp': int(datetime.now().timestamp() * 1000)})
        except Exception:
            pass
    return jsonify({'code': 500, 'message': '锟斤拷锟捷库不锟斤拷锟斤拷', 'data': None, 'timestamp': int(datetime.now().timestamp() * 1000)}), 500

@app.route('/api/public/tags', methods=['GET'])
def api_get_tags():
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                rows = conn.execute(text("SELECT tag_id, tag_name, COALESCE(item_count,0) FROM tb_tags ORDER BY tag_id")).fetchall()
                records = [{'tagId': r[0], 'tagName': r[1], 'itemCount': int(r[2])} for r in rows]
                return jsonify({'code': 200, 'message': 'success', 'data': {'records': records}, 'timestamp': int(datetime.now().timestamp() * 1000)})
            else:
                cur = conn.cursor()
                cur.execute("SELECT tag_id, tag_name, COALESCE(item_count,0) FROM tb_tags ORDER BY tag_id")
                rows = cur.fetchall()
                cur.close()
                records = [{'tagId': r[0], 'tagName': r[1], 'itemCount': int(r[2])} for r in rows]
                return jsonify({'code': 200, 'message': 'success', 'data': {'records': records}, 'timestamp': int(datetime.now().timestamp() * 1000)})
        except Exception:
            pass
    return jsonify({'code': 200, 'message': 'success', 'data': {'records': TAGS}, 'timestamp': int(datetime.now().timestamp() * 1000)})

# --- 4.2 锟矫伙拷锟接匡拷 (/api/user) ---

@app.route('/api/user/profile', methods=['GET','PUT'])
def api_user_profile():
    user = get_current_user()
    if not user:
        return jsonify({"code": 401, "message": "未锟斤拷权", "data": None}), 401
    if request.method == 'GET':
        return jsonify({
            "code": 200,
            "message": "success",
            "data": {
                "userId": user['userId'],
                "username": user['username'],
                "email": user['email'],
                "avatarUrl": user['avatarUrl']
            },
            "timestamp": int(datetime.now().timestamp() * 1000)
        })
    data = request.get_json() or {}
    new_username = data.get('username')
    new_email = data.get('email')
    new_avatar = data.get('avatarUrl')
    old_password = data.get('oldPassword')
    new_password = data.get('password')
    if new_password is not None:
        if user['password'] != (old_password or ''):
            return jsonify({"code": 400, "message": "锟斤拷锟斤拷锟诫不锟斤拷确", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
        user['password'] = new_password
    if new_username is not None:
        if any(u['username'] == new_username and u['userId'] != user['userId'] for u in USERS):
            return jsonify({"code": 400, "message": "锟矫伙拷锟斤拷锟窖达拷锟斤拷", "data": None, "timestamp": int(datetime.now().timestamp() * 1000)})
        session['username'] = new_username
        user['username'] = new_username
    if new_email is not None:
        user['email'] = new_email
    if new_avatar is not None:
        user['avatarUrl'] = new_avatar
    return jsonify({
        "code": 200,
        "message": "success",
        "data": {
            "userId": user['userId'],
            "username": user['username'],
            "email": user['email'],
            "avatarUrl": user['avatarUrl']
        },
        "timestamp": int(datetime.now().timestamp() * 1000)
    })

@app.route('/api/user/items/<int:item_id>/rate', methods=['POST'])
def api_rate_item(item_id):
    user = get_current_user()
    if not user:
        return jsonify({'code': 401, 'message': '未锟斤拷权'}), 401
    data = request.get_json()
    score = data.get('score')
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                with conn.begin():
                    conn.execute(text("DELETE FROM tb_ratings WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id})
                    conn.execute(text("INSERT INTO tb_ratings (user_id, item_id, score, created_at) VALUES (:uid, :iid, :score, :ts)"), {'uid': user['userId'], 'iid': item_id, 'score': int(score), 'ts': datetime.now()})
                    agg = conn.execute(text("SELECT AVG(score), COUNT(*) FROM tb_ratings WHERE item_id=:iid"), {'iid': item_id}).fetchone()
                    avg = float(agg[0]) if agg and agg[0] is not None else 0.0
                    cnt = int(agg[1]) if agg and agg[1] is not None else 0
                    conn.execute(text("UPDATE tb_items SET rating_avg=:avg, rating_count=:cnt WHERE item_id=:iid"), {'avg': avg, 'cnt': cnt, 'iid': item_id})
                return jsonify({'code': 200, 'message': '锟斤拷锟街成癸拷', 'data': {'ratingAvg': avg, 'ratingCount': cnt}, 'timestamp': int(datetime.now().timestamp() * 1000)})
            else:
                cur = conn.cursor()
                cur.execute("DELETE FROM tb_ratings WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                cur.execute("INSERT INTO tb_ratings (user_id, item_id, score, created_at) VALUES (%s, %s, %s, %s)", (user['userId'], item_id, int(score), datetime.now()))
                cur.execute("SELECT AVG(score), COUNT(*) FROM tb_ratings WHERE item_id=%s", (item_id,))
                agg = cur.fetchone()
                avg = float(agg[0]) if agg and agg[0] is not None else 0.0
                cnt = int(agg[1]) if agg and agg[1] is not None else 0
                cur.execute("UPDATE tb_items SET rating_avg=%s, rating_count=%s WHERE item_id=%s", (avg, cnt, item_id))
                conn.commit()
                cur.close()
                return jsonify({'code': 200, 'message': '锟斤拷锟街成癸拷', 'data': {'ratingAvg': avg, 'ratingCount': cnt}, 'timestamp': int(datetime.now().timestamp() * 1000)})
        except Exception:
            pass
    global RATINGS
    RATINGS = [r for r in RATINGS if not (r['userId'] == user['userId'] and r['itemId'] == item_id)]
    RATINGS.append({'ratingId': len(RATINGS) + 1, 'userId': user['userId'], 'itemId': item_id, 'score': score, 'createdAt': datetime.now().isoformat()})
    item = get_item_by_id(item_id)
    item_ratings = [r['score'] for r in RATINGS if r['itemId'] == item_id]
    item['ratingCount'] = len(item_ratings)
    item['ratingAvg'] = round(sum(item_ratings) / len(item_ratings), 2)
    return jsonify({'code': 200, 'message': '锟斤拷锟街成癸拷', 'data': {'ratingAvg': item['ratingAvg'], 'ratingCount': item['ratingCount']}, 'timestamp': int(datetime.now().timestamp() * 1000)})

@app.route('/api/user/items/<int:item_id>/favorite', methods=['POST'])
def api_favorite_item(item_id):
    user = get_current_user()
    if not user:
        return jsonify({'code': 401, 'message': '未锟斤拷权'}), 401
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                with conn.begin():
                    ex = conn.execute(text("SELECT 1 FROM tb_favorites WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id}).fetchone()
                    if ex:
                        conn.execute(text("DELETE FROM tb_favorites WHERE user_id=:uid AND item_id=:iid"), {'uid': user['userId'], 'iid': item_id})
                        return jsonify({'code': 200, 'message': '锟斤拷锟斤拷锟缴癸拷', 'data': {'isFavorited': False}, 'timestamp': int(datetime.now().timestamp() * 1000)})
                    else:
                        conn.execute(text("INSERT INTO tb_favorites (user_id, item_id, created_at) VALUES (:uid, :iid, :ts)"), {'uid': user['userId'], 'iid': item_id, 'ts': datetime.now()})
                        return jsonify({'code': 200, 'message': '锟斤拷锟斤拷锟缴癸拷', 'data': {'isFavorited': True}, 'timestamp': int(datetime.now().timestamp() * 1000)})
            else:
                cur = conn.cursor()
                cur.execute("SELECT 1 FROM tb_favorites WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                ex = cur.fetchone()
                if ex:
                    cur.execute("DELETE FROM tb_favorites WHERE user_id=%s AND item_id=%s", (user['userId'], item_id))
                    conn.commit()
                    cur.close()
                    return jsonify({'code': 200, 'message': '锟斤拷锟斤拷锟缴癸拷', 'data': {'isFavorited': False}, 'timestamp': int(datetime.now().timestamp() * 1000)})
                cur.execute("INSERT INTO tb_favorites (user_id, item_id, created_at) VALUES (%s, %s, %s)", (user['userId'], item_id, datetime.now()))
                conn.commit()
                cur.close()
                return jsonify({'code': 200, 'message': '锟斤拷锟斤拷锟缴癸拷', 'data': {'isFavorited': True}, 'timestamp': int(datetime.now().timestamp() * 1000)})
        except Exception:
            pass
    global FAVORITES
    existing = next((f for f in FAVORITES if f['userId'] == user['userId'] and f['itemId'] == item_id), None)
    is_favorited = False
    if existing:
        FAVORITES.remove(existing)
        is_favorited = False
    else:
        FAVORITES.append({'favoriteId': len(FAVORITES) + 1, 'userId': user['userId'], 'itemId': item_id, 'createdAt': datetime.now().isoformat()})
        is_favorited = True
    return jsonify({'code': 200, 'message': '锟斤拷锟斤拷锟缴癸拷', 'data': {'isFavorited': is_favorited}, 'timestamp': int(datetime.now().timestamp() * 1000)})

@app.route('/api/user/favorites', methods=['GET'])
def api_get_favorites():
    user = get_current_user()
    if not user:
        return jsonify({'code': 401, 'message': '未锟斤拷权'}), 401
    conn = get_db_connection()
    if conn is not None:
        try:
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                rows = conn.execute(text("SELECT i.item_id, i.title, i.type, i.author_director, i.release_year, i.rating_avg, i.rating_count, i.view_count, i.cover_url, i.description FROM tb_items i JOIN tb_favorites f ON f.item_id=i.item_id WHERE f.user_id=:uid ORDER BY f.created_at DESC"), {'uid': user['userId']}).fetchall()
                items = []
                for r in rows:
                    items.append({'itemId': r[0], 'title': r[1], 'type': r[2], 'authorDirector': r[3], 'releaseYear': r[4], 'ratingAvg': float(r[5]) if r[5] is not None else 0.0, 'ratingCount': int(r[6]) if r[6] is not None else 0, 'viewCount': int(r[7]) if r[7] is not None else 0, 'coverUrl': r[8], 'description': r[9]})
                return jsonify({'code': 200, 'message': 'success', 'data': {'records': items}, 'timestamp': int(datetime.now().timestamp() * 1000)})
            else:
                cur = conn.cursor()
                cur.execute("SELECT i.item_id, i.title, i.type, i.author_director, i.release_year, i.rating_avg, i.rating_count, i.view_count, i.cover_url, i.description FROM tb_items i JOIN tb_favorites f ON f.item_id=i.item_id WHERE f.user_id=%s ORDER BY f.created_at DESC", (user['userId'],))
                rows = cur.fetchall()
                cur.close()
                items = [{'itemId': r[0], 'title': r[1], 'type': r[2], 'authorDirector': r[3], 'releaseYear': r[4], 'ratingAvg': float(r[5]) if r[5] is not None else 0.0, 'ratingCount': int(r[6]) if r[6] is not None else 0, 'viewCount': int(r[7]) if r[7] is not None else 0, 'coverUrl': r[8], 'description': r[9]} for r in rows]
                return jsonify({'code': 200, 'message': 'success', 'data': {'records': items}, 'timestamp': int(datetime.now().timestamp() * 1000)})
        except Exception:
            pass
    fav_item_ids = [f['itemId'] for f in FAVORITES if f['userId'] == user['userId']]
    items = [i for i in ITEMS if i['itemId'] in fav_item_ids]
    return jsonify({'code': 200, 'message': 'success', 'data': {'records': items}, 'timestamp': int(datetime.now().timestamp() * 1000)})

@app.route('/api/user/recommendations/tag-based', methods=['GET'])
def api_tag_recommendations():
    # 锟斤拷模锟解：锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
    user = get_current_user()
    if not user:
         return jsonify({"code": 401, "message": "未锟斤拷权"}), 401
         
    recs = ITEMS[:5] # 锟津单凤拷锟斤拷前5锟斤拷
    for rec in recs:
        rec['tags'] = get_item_tags(rec['itemId'])
        
    return jsonify({
        "code": 200,
        "message": "success",
        "data": recs,
        "timestamp": int(datetime.now().timestamp() * 1000)
    })

# --- 4.3 锟斤拷锟捷接匡拷 ---

@app.route('/api/logout', methods=['POST'])
def api_logout():
    session.pop('username', None)
    return jsonify({"success": True, "message": "锟窖登筹拷"})

# 锟斤拷锟斤拷前锟剿碉拷锟斤拷锟接接匡拷
@app.route('/api/items', methods=['POST'])
def api_add_item():
    if 'username' not in session:
        return jsonify({'success': False, 'message': '未锟斤拷权'}), 401
    data = request.get_json()
    item_data = data.get('item')
    type_str = data.get('type')
    conn = get_db_connection()
    if conn is not None:
        try:
            content_type = 'book' if type_str == 'books' else 'movie'
            author_director = item_data.get('author') if type_str == 'books' else item_data.get('director')
            if DB.get('type') == 'sqlalchemy':
                from sqlalchemy import text
                with conn.begin():
                    row = conn.execute(text("INSERT INTO tb_items (title, type, author_director, release_year, rating_avg, rating_count, view_count, cover_url, description, created_at) VALUES (:title, :type, :ad, :year, :rating, 0, 0, :cover, :desc, :ts) RETURNING item_id"), {
                        'title': item_data.get('title'),
                        'type': content_type,
                        'ad': author_director,
                        'year': int(item_data.get('year')),
                        'rating': float(item_data.get('rating')),
                        'cover': item_data.get('cover'),
                        'desc': item_data.get('description'),
                        'ts': datetime.now()
                    }).fetchone()
                resp = jsonify({'success': True, 'message': '锟斤拷锟接成癸拷', 'data': {'itemId': row[0]}})
                conn.close()
                return resp
            else:
                cur = conn.cursor()
                cur.execute("INSERT INTO tb_items (title, type, author_director, release_year, rating_avg, rating_count, view_count, cover_url, description, created_at) VALUES (%s, %s, %s, %s, %s, 0, 0, %s, %s, %s) RETURNING item_id", (item_data.get('title'), content_type, author_director, int(item_data.get('year')), float(item_data.get('rating')), item_data.get('cover'), item_data.get('description'), datetime.now()))
                row = cur.fetchone()
                conn.commit()
                cur.close()
                return jsonify({'success': True, 'message': '锟斤拷锟接成癸拷', 'data': {'itemId': row[0]}})
        except Exception:
            pass
    new_id = max([i['itemId'] for i in ITEMS] or [0]) + 1
    new_item = {'itemId': new_id, 'title': item_data.get('title'), 'type': 'book' if type_str == 'books' else 'movie', 'authorDirector': item_data.get('author') if type_str == 'books' else item_data.get('director'), 'releaseYear': item_data.get('year'), 'ratingAvg': item_data.get('rating'), 'ratingCount': 0, 'viewCount': 0, 'coverUrl': item_data.get('cover'), 'description': item_data.get('description'), 'createdAt': datetime.now().isoformat()}
    ITEMS.append(new_item)
    return jsonify({'success': True, 'message': '锟斤拷锟接成癸拷'})

@app.route('/api/recommendations/<item_type>')
def api_recommendations_compat(item_type):
    """锟斤拷锟捷旧碉拷 script.js 锟斤拷锟矫ｏ拷直锟斤拷 js 锟斤拷锟斤拷锟斤拷锟�"""
    # 锟斤拷锟斤拷涌锟绞碉拷锟斤拷匣岜伙拷锟� script.js 锟斤拷锟矫ｏ拷锟斤拷锟斤拷锟斤拷锟皆凤拷锟斤拷一
    return api_get_items()

if __name__ == '__main__':
    app.run(debug=True, port=5000)
